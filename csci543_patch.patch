diff --git a/csci543_patch.patch b/csci543_patch.patch
new file mode 100644
index 0000000..35e4c2b
--- /dev/null
+++ b/csci543_patch.patch
@@ -0,0 +1,153 @@
+diff --git a/include/server/access/nbtree.h b/include/server/access/nbtree.h
+index 7493043..a0aa2c8 100644
+--- a/include/server/access/nbtree.h
++++ b/include/server/access/nbtree.h
+@@ -1329,4 +1329,9 @@ extern IndexBuildResult *btbuild(Relation heap, Relation index,
+ 								 struct IndexInfo *indexInfo);
+ extern void _bt_parallel_build_main(dsm_segment *seg, shm_toc *toc);
+ 
++/* GUC variables for B-Tree optimizations */
++extern bool btree_leaf_prefetch;
++extern bool btree_linear_scan;
++extern int btree_scan_threshold;
++
+ #endif							/* NBTREE_H */
+diff --git a/src/backend/access/nbtree/nbtsearch.c b/src/backend/access/nbtree/nbtsearch.c
+index e0bbb97..68372b4 100644
+--- a/src/backend/access/nbtree/nbtsearch.c
++++ b/src/backend/access/nbtree/nbtsearch.c
+@@ -366,6 +366,41 @@ _bt_binsrch(Relation rel,
+ 	if (unlikely(high < low))
+ 		return low;
+ 
++	/**
++	 * CSCI 543: Linear Scan Optimization
++	 * If enabled and under the threshold, use a loop isntead of binary search
++	 */
++	if (btree_linear_scan && high < btree_scan_threshold)
++    {
++        OffsetNumber i;
++        int32       lin_cmpval = key->nextkey ? 0 : 1;
++
++        elog(LOG, "CSCI 543: Linear scan on page with %d items", high);
++
++        /* Start from the first data key and find the first item >= target */
++        for (i = low; i <= high; i = OffsetNumberNext(i))
++        {
++            if (_bt_compare(rel, key, page, i) < lin_cmpval)
++                break;
++        }
++
++        /* * i now points to the first record >= key (or > key if nextkey is true).
++         * This matches the state of 'low' at the end of the original binary search.
++         */
++        if (P_ISLEAF(opaque))
++        {
++            if (key->backward)
++                return OffsetNumberPrev(i);
++            return i;
++        }
++
++        /* * On internal pages, we must return the child pointer for the last 
++         * key < (or <=) the search key. This requires stepping back.
++         */
++        return OffsetNumberPrev(i);
++    }
++
++
+ 	/*
+ 	 * Binary search to find the first key on the page >= scan key, or first
+ 	 * key > scankey when nextkey is true.
+@@ -2208,6 +2243,16 @@ _bt_readnextpage(IndexScanDesc scan, BlockNumber blkno, ScanDirection dir)
+ 			so->currPos.buf = _bt_getbuf(rel, blkno, BT_READ);
+ 			page = BufferGetPage(so->currPos.buf);
+ 			opaque = BTPageGetOpaque(page);
++
++			/* * CSCI 543: Leaf-page prefetching logic.
++             * We just landed on a new page (page 'blkno'). 
++             * Now we hint the OS to prefetch the sibling of THIS page.
++             */
++            if (btree_leaf_prefetch && BlockNumberIsValid(opaque->btpo_next))
++            {
++                PrefetchBuffer(rel, MAIN_FORKNUM, opaque->btpo_next);
++            }
++
+ 			/* check for deleted page */
+ 			if (!P_IGNORE(opaque))
+ 			{
+diff --git a/src/backend/utils/misc/guc_tables.c b/src/backend/utils/misc/guc_tables.c
+index c42fccf..9646765 100644
+--- a/src/backend/utils/misc/guc_tables.c
++++ b/src/backend/utils/misc/guc_tables.c
+@@ -513,6 +513,11 @@ char	   *event_source;
+ bool		row_security;
+ bool		check_function_bodies = true;
+ 
++// new option for csci543 project 1
++bool 		btree_leaf_prefetch = false;
++bool 		btree_linear_scan = false;
++int 		btree_scan_threshold = 100;
++
+ /*
+  * This GUC exists solely for backward compatibility, check its definition for
+  * details.
+@@ -2026,6 +2031,28 @@ struct config_bool ConfigureNamesBool[] =
+ 		NULL, NULL, NULL
+ 	},
+ 
++	// new options for project 1
++	// the prefetch switch: this entry registers the toggle for your leaf-page lookahead optimization
++	{
++		{"btree_leaf_prefetch", PGC_USERSET, DEVELOPER_OPTIONS,
++			gettext_noop("Enable leaf-page prefetching in B-Tree scans."),
++			NULL
++		},
++		&btree_leaf_prefetch,
++		false,
++		NULL, NULL, NULL
++	},
++	// the linear scan switch: this entry registers the toggle that tells the search logic to use a linear scan instead of a binary search
++	{
++		{"btree_linear_scan", PGC_USERSET, DEVELOPER_OPTIONS,
++			gettext_noop("Enable linear scan instead of binary search in B-Tree pages."),
++			NULL
++		},
++		&btree_linear_scan,
++		false,
++		NULL, NULL, NULL
++	},
++
+ 	/* End-of-list marker */
+ 	{
+ 		{NULL, 0, 0, NULL, NULL}, NULL, false, NULL, NULL, NULL
+@@ -3652,6 +3679,16 @@ struct config_int ConfigureNamesInt[] =
+ 		SCRAM_SHA_256_DEFAULT_ITERATIONS, 1, INT_MAX,
+ 		NULL, NULL, NULL
+ 	},
++	// Integer threshold for linear scan logic: this is the limit on how many items to scan before giving up
++	{
++    {"btree_scan_threshold", PGC_USERSET, DEVELOPER_OPTIONS,
++        gettext_noop("Threshold for switching to linear scan in B-Tree."),
++        NULL
++    },
++    &btree_scan_threshold,
++    100, 0, INT_MAX,
++    NULL, NULL, NULL
++},
+ 
+ 	/* End-of-list marker */
+ 	{
+diff --git a/src/include/access/nbtree.h b/src/include/access/nbtree.h
+index 7493043..a0aa2c8 100644
+--- a/src/include/access/nbtree.h
++++ b/src/include/access/nbtree.h
+@@ -1329,4 +1329,9 @@ extern IndexBuildResult *btbuild(Relation heap, Relation index,
+ 								 struct IndexInfo *indexInfo);
+ extern void _bt_parallel_build_main(dsm_segment *seg, shm_toc *toc);
+ 
++/* GUC variables for B-Tree optimizations */
++extern bool btree_leaf_prefetch;
++extern bool btree_linear_scan;
++extern int btree_scan_threshold;
++
+ #endif							/* NBTREE_H */
diff --git a/include/server/access/nbtree.h b/include/server/access/nbtree.h
index 7493043..a0aa2c8 100644
--- a/include/server/access/nbtree.h
+++ b/include/server/access/nbtree.h
@@ -1329,4 +1329,9 @@ extern IndexBuildResult *btbuild(Relation heap, Relation index,
 								 struct IndexInfo *indexInfo);
 extern void _bt_parallel_build_main(dsm_segment *seg, shm_toc *toc);
 
+/* GUC variables for B-Tree optimizations */
+extern bool btree_leaf_prefetch;
+extern bool btree_linear_scan;
+extern int btree_scan_threshold;
+
 #endif							/* NBTREE_H */
diff --git a/src/.gitignore b/src/.gitignore
index a66aac0..4c55ed5 100644
--- a/src/.gitignore
+++ b/src/.gitignore
@@ -1,3 +1,7 @@
 /Makefile.global
 /Makefile.port
 /Makefile.custom
+
+bin/
+logfile
+postgres
diff --git a/src/backend/access/nbtree/nbtsearch.c b/src/backend/access/nbtree/nbtsearch.c
index e0bbb97..f6c1ba4 100644
--- a/src/backend/access/nbtree/nbtsearch.c
+++ b/src/backend/access/nbtree/nbtsearch.c
@@ -366,6 +366,46 @@ _bt_binsrch(Relation rel,
 	if (unlikely(high < low))
 		return low;
 
+	/**
+	 * CSCI 543: Linear Scan Optimization
+	 * If enabled and under the threshold, use a loop isntead of binary search
+	 */
+	if (btree_linear_scan && high < btree_scan_threshold)
+    {
+        OffsetNumber i;
+        int32       lin_cmpval = key->nextkey ? 0 : 1;
+
+        // elog(LOG, "CSCI 543: Linear scan on page with %d items", high);
+
+		/* SAFETY: If high < low, the page is empty or only has a high key. 
+         * We should have caught this above, but let's be safe. */
+        if (high < low)
+             return low;
+
+        /* Start from the first data key and find the first item >= target */
+        for (i = low; i <= high; i = OffsetNumberNext(i))
+        {
+            if (_bt_compare(rel, key, page, i) < lin_cmpval)
+                break;
+        }
+
+        /* * i now points to the first record >= key (or > key if nextkey is true).
+         * This matches the state of 'low' at the end of the original binary search.
+         */
+        if (P_ISLEAF(opaque))
+        {
+            if (key->backward)
+                return OffsetNumberPrev(i);
+            return i;
+        }
+
+        /* * On internal pages, we must return the child pointer for the last 
+         * key < (or <=) the search key. This requires stepping back.
+         */
+        return OffsetNumberPrev(i);
+    }
+
+
 	/*
 	 * Binary search to find the first key on the page >= scan key, or first
 	 * key > scankey when nextkey is true.
@@ -2208,6 +2248,16 @@ _bt_readnextpage(IndexScanDesc scan, BlockNumber blkno, ScanDirection dir)
 			so->currPos.buf = _bt_getbuf(rel, blkno, BT_READ);
 			page = BufferGetPage(so->currPos.buf);
 			opaque = BTPageGetOpaque(page);
+
+			/* * CSCI 543: Leaf-page prefetching logic.
+             * We just landed on a new page (page 'blkno'). 
+             * Now we hint the OS to prefetch the sibling of THIS page.
+             */
+            if (btree_leaf_prefetch && BlockNumberIsValid(opaque->btpo_next))
+            {
+                PrefetchBuffer(rel, MAIN_FORKNUM, opaque->btpo_next);
+            }
+
 			/* check for deleted page */
 			if (!P_IGNORE(opaque))
 			{
diff --git a/src/backend/utils/misc/guc_tables.c b/src/backend/utils/misc/guc_tables.c
index c42fccf..9646765 100644
--- a/src/backend/utils/misc/guc_tables.c
+++ b/src/backend/utils/misc/guc_tables.c
@@ -513,6 +513,11 @@ char	   *event_source;
 bool		row_security;
 bool		check_function_bodies = true;
 
+// new option for csci543 project 1
+bool 		btree_leaf_prefetch = false;
+bool 		btree_linear_scan = false;
+int 		btree_scan_threshold = 100;
+
 /*
  * This GUC exists solely for backward compatibility, check its definition for
  * details.
@@ -2026,6 +2031,28 @@ struct config_bool ConfigureNamesBool[] =
 		NULL, NULL, NULL
 	},
 
+	// new options for project 1
+	// the prefetch switch: this entry registers the toggle for your leaf-page lookahead optimization
+	{
+		{"btree_leaf_prefetch", PGC_USERSET, DEVELOPER_OPTIONS,
+			gettext_noop("Enable leaf-page prefetching in B-Tree scans."),
+			NULL
+		},
+		&btree_leaf_prefetch,
+		false,
+		NULL, NULL, NULL
+	},
+	// the linear scan switch: this entry registers the toggle that tells the search logic to use a linear scan instead of a binary search
+	{
+		{"btree_linear_scan", PGC_USERSET, DEVELOPER_OPTIONS,
+			gettext_noop("Enable linear scan instead of binary search in B-Tree pages."),
+			NULL
+		},
+		&btree_linear_scan,
+		false,
+		NULL, NULL, NULL
+	},
+
 	/* End-of-list marker */
 	{
 		{NULL, 0, 0, NULL, NULL}, NULL, false, NULL, NULL, NULL
@@ -3652,6 +3679,16 @@ struct config_int ConfigureNamesInt[] =
 		SCRAM_SHA_256_DEFAULT_ITERATIONS, 1, INT_MAX,
 		NULL, NULL, NULL
 	},
+	// Integer threshold for linear scan logic: this is the limit on how many items to scan before giving up
+	{
+    {"btree_scan_threshold", PGC_USERSET, DEVELOPER_OPTIONS,
+        gettext_noop("Threshold for switching to linear scan in B-Tree."),
+        NULL
+    },
+    &btree_scan_threshold,
+    100, 0, INT_MAX,
+    NULL, NULL, NULL
+},
 
 	/* End-of-list marker */
 	{
diff --git a/src/include/access/nbtree.h b/src/include/access/nbtree.h
index 7493043..a0aa2c8 100644
--- a/src/include/access/nbtree.h
+++ b/src/include/access/nbtree.h
@@ -1329,4 +1329,9 @@ extern IndexBuildResult *btbuild(Relation heap, Relation index,
 								 struct IndexInfo *indexInfo);
 extern void _bt_parallel_build_main(dsm_segment *seg, shm_toc *toc);
 
+/* GUC variables for B-Tree optimizations */
+extern bool btree_leaf_prefetch;
+extern bool btree_linear_scan;
+extern int btree_scan_threshold;
+
 #endif							/* NBTREE_H */
